from graphshw import WeightedGraph
import random

# Student Name: <put your name here>
#
# Programming Assignment 3
#
# What to Submit: Submit the following files once you complete
# the assignment:
# (a) Your modified graphshw.py which has your implementations of BellmanFord and Dijkstra.
# (b) Your completed shortestpathscomparison.py (don't rename either of these files).
# (c) A text file containing the table of timing results generated by the function
#     you implemented in step 3 of the assignment.
# (d) Your answers to the questions from step 6 should either be in comments in this
#     file or a separate text file.
# (e) If you do the extra credit part, then make sure you include the additional .py
#     file with your extra credit solution, as well as your parser from assignment 2
#     (so I don't have to track it down again).
# (f) You do NOT need to submit the other .py files that graphshw.py imports.  I gave
#     them to you.  You are not modifying them.  So I already have them.
#
#
# 1) Implement bellmanFord inside the WeightedGraph class of
#    graphshw.py.  Do not change the method name, its parameters, etc.
#    See comments inside that method for details.
#
# 2) Implement dijkstra inside the WeightedGraph class of
#    graphshw.py.  Do not change the method name, its parameters, etc.
#    See comments inside that method for details.
#
# (3) Implement the timeShortestPathAlgs function later in this file
#     to do the following:
#     -- Call randomWeightedGraph tha I provided below
#        to generate a random weighted
#        graph with 16 vertices and 120 edges
#        (i.e., completely connected--all possible undirected edges, other than loops)
#        and weights random in interval 1 to 10 inclusive.
#     -- Read documentation of timeit (https://docs.python.org/3/library/timeit.html)
#        And also watch the videos I posted explaining its usage.
#     -- Use timeit to time both Bellman-Ford and Dijkstra that you implemented
#        in steps 1 and 2 on this graph.  I already imported the graphshw module
#        at the top.
#        The number parameter to timeit controls how many times the thing you're
#        timing is called.
#        To get meaningful times, you will need to experiment with this
#        a bit.  E.g., increase it if the times are too small.  Use the same
#        value of number for timing both algorithms.
#        IMPORTANT: Definitely don't use the default value of number, which is
#        something like 1000000 (e.g., the sun might explode before your program
#        finishes on the larger graphs below if you leave it at 10000000).
#     -- Make sure you don't include the time to generate the weighted graph in your
#        times.
#     -- Now repeat this for a graph with 64 vertices and 2016 edges.
#     -- Now repeat this for a graph with 256 vertices and 32640 edges.
#     -- Repeat this again for 16 vertices and 32 edges.
#     -- Repeat yet again with 64 vertices and 128 edges.
#     -- Repeat yet again with 256 vertices and 512 edges.
#    
#     -- Have the timeShortestPathAlgs function output the timing data in a
#        table, with columns for number of vertices, number of edges, and time.
#     -- If you want, you can include larger graphs.
#        The pattern I used when indicating what size to use:
#        Dense graphs: v, e=v*(v-1)/2.
#        Sparse: v, e=2*v.
#        For example, if you want to continue the experimentation with
#        larger graphs, you might
#        try 1024 vertices with 523776 edges (dense graph),
#        1024 vertices with 2048 edges (sparse).
#     -- When you are timing the algorithms you can pass whatever vertex id you
#        want as the source vertex.  It shouldn't affect the runtime by much,
#        if at all.  The random weighted graphs are such that there exists paths
#        to any destination from any source, even the sparse graphs so timing
#        data shouldn't be affected much by source vertex.
#
# 4) Write some code in the if main block at the bottom of this file
#    to test that your Bellman Ford and Dijkstra implementations work correctly.
#    I suggest constructing a WeightedGraph from one of the textbook examples
#    since you know the correct solution to those.
#
# 5) After that code, but in your if main block, call your function that
#    generates the timing data.  Make sure you save that output to a text file.
#    If you run in IDLE, then just copy and paste from the shell into a text file.
#    If you run from the command line, you can just redirect the output to a text file.
#
# 6) Once you have the timing data, answer these questions, either right here in comments
#    or as a separate text file:
#     (a) Given the asymptotic runtimes (i.e., the big-O analysis), when should you expect
#         Bellman Ford to be faster (e.g., in terms of graph density)?  When should
#         you expect Dijkstra's algorithm to be faster?  Be careful, question (a) can
#         be considered a trick question.
#     (b) Does graph density affect performance?  By this mean, was one algorithm
#         faster for dense graphs, but the other for sparse graphs?  Or was the same
#         algorithm faster in both cases?
#     (c) Does size (in number of vertices) of the graph otherwise
#         affect performance?  By this I mean was one algorithm always faster than
#         the other?  Or was one faster for a low number of vertices and the other
#         faster when the number of vertices was higher?
#     (d) Are your timing results consistent with your answer to question (a)?
#         If not, what do you think caused the discrepancy?
#
# 7) OPTIONAL STEP (up to 15 points extra credit): In programming assignment 2, you
#    implemented a parser for some
#    highway graph data files.  Implement another python module (i.e., another .py file)
#    with an if main block where you: (a) get a highway graph filename from the
#    command line, (b) use your parser from assignment 2 to get a WeightedGraph (you'll
#    need an import statement for your parser), and (c) use either Bellman Ford or
#    Dijkstra to compute the Single Source Shortest Paths for the source vertex of
#    your choice.


def randomWeightedGraph(v,e,min_w,max_w) :
    """Generates and returns a random weighted
    graph with v vertices and e different edges.

    Keyword arguments:
    v - number of vertices
    e - number of edges
    min_w - minimum weight
    max_w - maximum weight
    """

    edges = [ (random.randrange(0,i),i) for i in range(1,v) ]

    # if desired number of edges greater than length of current edge list, then add more edges
    if e > len(edges) :
        edgeSet = { x for x in edges }
        notYetUsedEdges = [ (y,x) for x in range(1,v) for y in range(x) if (y,x) not in edgeSet ]
        random.shuffle(notYetUsedEdges)
        count = e - len(edges)
        count = min(count, len(notYetUsedEdges))
        for i in range(count) :
            edges.append(notYetUsedEdges.pop())

    # generate random edge weights
    weights = [ random.randint(min_w, max_w) for x in range(len(edges)) ]

    # construct a Digraph with the lists of edges and weights generated
    G = WeightedGraph(v, edges, weights)
    return G


def timeShortestPathAlgs() :
    """Generates a table of timing results comparing Dijkstra and Bellman-Ford."""
    pass


if __name__ == "__main__" :
    # Here is where you write some code to test that your algorithms
    # are correct.
    #
    # It is also where you will call your timeShortestPathAlgs function.
    # Don't forget to save output to a text file.
    pass
